"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryClient = void 0;
const services_1 = require("./services");
class TelemetryClient {
    constructor(config) {
        this.apiClient = new services_1.ApiClient();
        this.queue = [];
        this.config = config !== null && config !== void 0 ? config : true;
    }
    sendTelemetry(rawTelemetry) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const telemetry = this.prepareTelemetry(rawTelemetry);
                if (Object.keys(telemetry).length === 0) {
                    return;
                }
                this.debounce && clearTimeout(this.debounce);
                this.setDebounce();
                this.queue.push(telemetry);
            }
            catch (_a) {
                // ignore
            }
        });
    }
    sendBulk() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.queue.length) {
                    yield this.apiClient.createTelemetry(this.queue);
                    this.queue.length = 0;
                }
            }
            catch (e) {
                // ignore
            }
        });
    }
    prepareTelemetry(rawTelemetry) {
        var _a, _b, _c, _d;
        if (typeof this.config === 'boolean') {
            return this.config ? rawTelemetry : {};
        }
        if (Object.keys(this.config).length === 0) {
            return {};
        }
        const mappedConfig = {
            libVersion: true,
            libVersionHash: true,
            methodName: true,
            authentication: (_a = this.config.allowedToPassAuthenticationType) !== null && _a !== void 0 ? _a : true,
            strict_GDPR_enabled: true,
            baseRequestConfigUsed: true,
            onResponseMiddlewareUsed: true,
            onErrorMiddlewareUsed: true,
            callbackUsed: true,
            queryExists: true,
            bodyExists: true,
            headersExists: true,
            requestStatusCode: (_b = this.config.allowedToPassRequestStatusCode) !== null && _b !== void 0 ? _b : true,
            requestStartTime: (_c = this.config.allowedToPassRequestTimings) !== null && _c !== void 0 ? _c : true,
            requestEndTime: (_d = this.config.allowedToPassRequestTimings) !== null && _d !== void 0 ? _d : true,
            noCheckAtlassianToken: true,
        };
        const preparedTelemetry = {};
        const entries = Object.entries(mappedConfig);
        entries.forEach(([key, allowed]) => {
            if (allowed) {
                // @ts-ignore
                preparedTelemetry[key] = rawTelemetry[key];
            }
        });
        return preparedTelemetry;
    }
    setDebounce() {
        this.debounce = setTimeout(() => this.sendBulk(), 10000);
    }
}
exports.TelemetryClient = TelemetryClient;
